---
title: "[Бизнес-Аналитик от SF Education](https://sf.education/businessanalyst)"
author: "[Alexanyan Andron](https://www.alexanyan.tech/)"
output: 
  html_document:
   toc: TRUE
   theme: "readable"
   highlight: "textmate"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Пролог 

В этой презентации мы с Вами рассмотрим малую часть того, что Вы сможете узнать на курсе [Бизнес-Аналитик от SF Education](https://sf.education/businessanalyst).  

Коротко о том, **почему нужно изучать именно язык R**: 

- В первую очередь, он востребован среди работодателей в сферах *аналитики* и *Data Science*
- Язык достаточно многофункциональный и его инструментами можно решать большое количество задач из разных областей: от статистики до биоинформатики
- Код на R выглядит достаточно читаемо и понятно- серьезных сложностей с изучением языка не возникнет
- В R огромное количество пакетов на любой вкус - они делают работу с данными приятной и эффективной, а также позволяют строить красивые визуализации, интерактивные дашборды и даже делать аналитические веб-приложения

Начнем!

# Обработка данных 

Давайте загрузим датасет в рабочую область. Анализировать мы будем данные по коронавирусу, чтобы сильно не усложнять задачу и не вникать в специфику. 

```{r dataset}
data <- read.csv(file = 'covid_19_clean_complete.csv') #Загружаем данные
str(data) #Выводим структуру загруженного датасета
```

Перед тем как идти дальше, смотрим структуру нашего датасета - у нас есть информация по Странам и Регионам, широта и долгота, Дата наблюдения, а также показатели по Заболеваемости, Смертности и Выздоровлениям. При этом, для каждого поля указан соответствующий тип данных - целые числа, факторы или дробные числа. Это тоже важно, при дальнейшей обработке с этим могут возникнуть проблемы. 

Теперь давайте сделаем то, с чем постоянно приходится сталкиваться каждому аналитику - отфильтруем наши данные и подготовим их для дальнейшей обработки. Для этого используем одну из самых популярных библиотек - **dplyr**. Давайте будем смотреть только цифры по Соединенным Штатам Америки, с разбивкой по каждому штату отдельно - найдем общее количество Заболевших, Смертей и Выздоровлений, а также добавим новый вычислимый столбец -  процент смертности. 

```{r dplyr, include=FALSE}
library(dplyr) #подключаем библиотеку
```

```{r dplyr_data}
data <- data %>% #берем исходные данные
  filter(Country.Region == 'US') %>% #фильтруем Штаты
  group_by(Province.State) %>% #группируем по каждому штату отдельно
  summarise('Confirmed' = sum(Confirmed), 'Deaths' = sum(Deaths), 'Recovered' = sum(Recovered)) %>% #считаем общее количество Заболевших, Смертей и Выздоровлений
  mutate('Death percentage' = Deaths/Confirmed*100) %>% #добавляем столбец с процентом смертности
  arrange(desc(`Death percentage`)) #упорядочиваем по смертности

str(data) #смотрим структуру полученных данных
```
Если Вы обратите внимание на верхнюю строчку, то увидите, что теперь у нас не **data.frame**, как был в начале, а новый тип - **tibble**. **Tibble** - это более современный и удобный инструмент работы с данными: он взял от **data.frame** все лучшее и избавился от недостатков. Однако, не будем об этом подробно. Главное - мы видим, что строк было 15447 и 8 переменных, а после наших преобразований - 56 строк и 5 столбцов. Отлично, значит все сработало как надо!

# Делаем таблицу красивой 

Давайте пойдем дальше. Наши данные обработаны и готовы, например, для дальнейшего построение графиков. Однако, давайте еще чуть-чуть поработаем с нашей таблицей и сделаем ее красивой, чтобы не стыдно было коллегам показать или в интернет выложить :) 

Для этого мы будем использовать новый пакет - **gt** для форматирования таблиц. 

```{r gt, include=FALSE}
#install.packages('gt') #устанавливаем библиотеку
library(gt) #подключаем библиотеку
```

```{r gt_format}
data %>% 
  gt() %>% #передаем нашу tibble библиотеке gt
  tab_header(title = md("This is the COVID-19 dataset in **gt**"), 
             subtitle = "Join SF Education Business Analyst Course!") %>% #добавляем заголовок и подзаголовок
  tab_source_note(md("[Author: Alexanyan Andron](https://www.alexanyan.tech/)")) %>% #Добавляем ссылку на автора cнизу
  tab_spanner(label = "Initial data", 
              columns = c("Confirmed", "Deaths", "Recovered")) %>% #объединяем несколько столбцов в общую группу
  fmt_number(columns = vars(`Death percentage`), decimals = 1) %>% #форматируем число знаков после запятой
  data_color(columns = vars(`Death percentage`), 
             colors = scales::col_numeric(palette = c("green", "blue", "orange", "red"), 
                                      domain = c(0, 11))) %>% #раскрашиваем столбец смертности в зависимости от значения
  summary_rows(groups = NULL, columns = vars(Deaths, Confirmed, Recovered), 
               fns = list(TOTAL = "sum")) #добавляем итоги в конец таблицы
```


Согласитесь, выглядит симпатично. 

# А что по графикам? 

Так, с таблицами разобрались, теперь давайте перейдем к визуализациям. Для построения графиков будем пользоваться пакетом **ggplot2** для построения продвинутых визуализаций. На самом деле, его возможности огромны, особенно с учетом разных интеграций со сторонними пакетами, но мы рассмотрим достаточно простой пример. 

Учитывая, что наша таблица содержит максимально простые данные, давайте вернемся к исходному датасету и построим графики заболеваемости в трех странах - Испания, Италия и Иран. Почему именно они? Да просто чтобы масштаб был примерно одинаковый. 

```{r ggplot2, include=FALSE}
library(ggplot2) #подключаем библиотеку
```


```{r ggplot2_data}
data <- read.csv(file = 'covid_19_clean_complete.csv') #еще раз загружаем данные

data <- data %>%
  filter(Country.Region %in% c('Spain','Italy','Iran')) %>%  #фильтруем по странам
  group_by(Country.Region, Date) %>% #группируем по странам и датам
  summarise('Confirmed' = sum(Confirmed), 'Deaths' = sum(Deaths), 
            'Recovered' = sum(Recovered)) %>% #суммируем цифры по группам
  mutate(Date = 
      format(as.Date(as.character(Date), format = "%m/%d/%y"), format = "%m/%d"))  #изменяем формат даты на привычный нам

gg <- ggplot() + 
  geom_col(data = data, aes(x = Date, y = Confirmed, 
                            fill = Country.Region), col = 'black') + #строим слолбчатую диаграмму
  facet_wrap(~Country.Region) + #разбиваем по разным графикам разные страны
  theme_bw() + #меняем тему на черно-белую
  theme(axis.text.x=element_blank()) #убираем нагроможденные подписи на оси Х 


gg #выводим график
```

# Добавим разнообразия - сделаем интерактивный дашборд

Однако, график выглядит несколько скучно в силу своей специфики. Давайте превратим его в интерактивный дашборд, чтобы можно было поводить мышкой и посмотреть значения каждого столбца на графике! Тем, кто знаком с Power BI, Tableau и прочими BI-сервисами, такой подход знаком. Будем использовать библиотеку **plotly**.

```{r plotly, include=FALSE}
library(plotly) #подключаем библиотеку
```

```{r plotly_output}
ggplotly(gg) #строим дашборд
```

# Эпилог

Вы видите, мы сделали уже достаточно много всего, не потратив при этом много строчек кода, сил и не используя какие-то суперсложные функции. В принципе, если Вы владеете английским хотя бы на среднем уровне, и у Вас есть желание изучить язык R поглубже - Вы с легкостью это сможете сделать, а [мы Вам в этом поможем](https://sf.education/businessanalyst)!

Естественно, это далеко не все возможности языка R - Вы сможете создавать намного более крутые графики, делать намного более глубокую аналитику и вообще делать еще много чего. Например, вся эта презентация сделано с помощью инструмента **Rmarkdown** - он Вам тоже пригодится, поверьте :) 

*Исходный код rmarkdown-документа доступен [здесь](https://github.com/andron23/bysiness_analyst_free_course_rmarkdown).*
